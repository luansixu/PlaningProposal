# 魔鬼契约（原型）— 1 回合可通关最小技术规格 v0.1

> 目标：只做“1 个契约 + 1 个事件 + 结算界面”的最小闭环，让另一个开发 Agent 可以直接开工并跑通流程。  
> 技术：纯 Web（单页），LLM 负责“契约生成/谈判改写/事件生成”，输出严格 JSON + 短文案。  
> 安全：**不把真实 API Key 写进仓库/文档**。你提供的 Key 我已收到，但这里只给 `.env`/运行时输入方案。

---

## 0. 本原型范围（只做这些）

- **局外**：主菜单 3 个按钮
  - `开始人生`（可用）
  - `成就`（只展示占位文案）
  - `升级`（置灰，提示“开发中”）
- **局内（仅 1 回合）**
  - 开局资源初始化
  - （可选）开场事件：50% 概率触发 0/1 个事件
  - 生成 1 份契约（同一魔鬼）
  - 玩家可：`查看全文`、`法宝`（提示漏洞数量）、`谈判`（最多 2 次；原型不做“能力加次数”）、`接受`、`拒绝`
  - 结算条款（含最低 -10 灵魂）
  - 生成并执行 **1 个事件**（节点 2 between_rounds）
  - 进入胜利/失败结算页（本原型：完成 1 回合且灵魂>0 视为胜利）

---

## 1. 关键体验（必须实现）

- **摘要/全文分层**：主界面只看摘要；点开全文才能看到“坑点语句”。  
- **可高亮引用**：全文按“段落→句子”拆分，每一句可点击引用到谈判弹窗。  
- **两层判定**：
  - 只指出漏洞句（layer1）→ 魔鬼可狡辩/反砍  
  - 指出漏洞句 + 指出具体问题（layer2）→ 魔鬼必须让步
- **首轮致命试探（按等级概率）**：
  - 本原型固定魔鬼等级为 `small`，致命试探出现概率 **30%**  
  - 若生成了致命试探，摘要必须显示非剧透警告：`本契约含“致命定义条款”，建议阅读全文。`

---

## 2. 状态与数值（最小集）

### 2.1 初始值

- `happiness = 60`（0–100）
- `gold = 0`（0+）
- `soul = 100`（0–100）
- `round = 1`

### 2.2 失败/胜利

- **失败**：任意结算后 `soul <= 0` → 失败页：`你的灵魂已被恶魔收走`
- **胜利（原型版）**：执行完“契约结算 + 事件结算”且 `soul > 0` → 胜利页（展示金币/幸福/灵魂）

### 2.3 开局结算（本原型可先不做）

为降低实现量，原型可先跳过“幸福影响灵魂 + 回合税”，直接进入契约；若要做，按完整版第 5.3。

---

## 3. UI 结构（必须按这个做，避免跑偏）

### 3.1 主界面

- 顶部资源条：金币/幸福/灵魂
- 左侧列表：能力/诅咒（原型可先为空，仅占位容器）
- 中央卡片：契约摘要
- 按钮：`查看全文` / `谈判` / `法宝` / `接受` / `拒绝`
- 右侧：历史契约（原型可先只存 1 条并显示）

### 3.2 弹窗

- **全文弹窗**：显示分段分句；每句左侧有“引用”按钮（点击把 `p,s,text` 带入谈判弹窗）
- **谈判弹窗**：
  - 引用片段（只读，可为空）
  - 我的解释（输入）
  - 我的反提案（输入）
  - 发送（回车/按钮），显示对话记录
- **法宝提示弹窗**：只显示“本契约存在 X 处漏洞/错误”，不指出位置

---

## 4. LLM 调用（本原型固定 3 次以内，够跑通）

> 你允许加调用次数，但原型先控在 3 次内，便于调试。

1) `offer_generate`：生成契约（摘要/全文/漏洞/JSON/可能致命试探）
2) `negotiate`：仅当玩家谈判时调用（最多 2 次）
3) `event_generate`：生成 1 个事件（between_rounds）

---

## 5. 数据契约（JSON Schema：必须严格遵守）

### 5.1 `offer_generate` 输出

```json
{
  "devil": { "tier": "small", "name": "string" },
  "display_text": "string",
  "offer": {
    "summary": "string",
    "full_text": "string",
    "min_accept_soul_cost": 10,
    "deltas_on_accept": { "gold": 0, "happiness": 0, "soul": 0 },
    "abilities_granted": [],
    "curses_granted": []
  },
  "text_index": {
    "paragraphs": [
      { "p": 0, "sentences": [ { "s": 0, "text": "string" } ] }
    ]
  },
  "loopholes": [
    {
      "id": "L1",
      "quote_ref": { "p": 0, "s": 0 },
      "player_detect_keywords": ["string"],
      "player_issue_keywords": ["string"],
      "issue_explanation": "string",
      "trigger_condition": {
        "type": "on_accept",
        "if": [],
        "then": { "apply": "penalty|set_soul_zero|grant_curse", "refId": "string|null" }
      },
      "penalty_on_accept": { "gold": 0, "happiness": 0, "soul": 0 },
      "defuse_actions": ["clarify_clause", "remove_condition", "cap_penalty", "swap_to_gold", "swap_to_happiness"],
      "severity": 1
    }
  ],
  "deadly_probe": {
    "present": false,
    "spawn_chance": 0.3,
    "warning_text": "本契约含“致命定义条款”，建议阅读全文。"
  }
}
```

硬约束：

- `loopholes.length`：本原型固定 **4–6**（便于体验“读条款”）
- `deadly_probe.present=true` 时：必须有一个漏洞的 `then.apply = "set_soul_zero"` 或某个可检测条件导致归零

### 5.2 `negotiate` 输出（谈判改写）

```json
{
  "display_text": "string",
  "updated_offer": {
    "summary": "string",
    "full_text": "string",
    "deltas_on_accept": { "gold": 0, "happiness": 0, "soul": 0 }
  },
  "loophole_check": {
    "matched_loophole_id": "L1|null",
    "layer1_detected": true,
    "layer2_issue_explained": false,
    "is_full_success": false,
    "confidence": { "keyword_score": 0.0, "semantic_score": 0.0, "final_score": 0.0 },
    "devil_response_mode": "concede|argue|counter_offer",
    "devil_concession": []
  },
  "conversation_log_append": [
    { "role": "player|devil|system", "content": "string" }
  ]
}
```

判定逻辑（开发端执行）：

- `keyword_score`：玩家文本与 `player_*_keywords` 交集计分（0–1）
- `semantic_score`：由 LLM 输出（0–1）
- `final_score = 0.4*keyword + 0.6*semantic`
- `layer1_detected = (keyword_detect_hit>=1) OR (semantic_score>=0.70)`
- `layer2_issue_explained = (keyword_issue_hit>=1) AND (semantic_score>=0.75)`

### 5.3 `event_generate` 输出

```json
{
  "display_text": "string",
  "event": {
    "node": "between_rounds",
    "event_text": "string",
    "choices": [
      { "id": "A", "choice_text": "string", "deltas": { "gold": 0, "happiness": 0, "soul": 0 } },
      { "id": "B", "choice_text": "string", "deltas": { "gold": 0, "happiness": 0, "soul": 0 } }
    ]
  }
}
```

---

## 6. 校验、重试、降级（必须做，否则必卡死）

- **JSON 解析校验**：缺字段/类型不对/NaN/Infinity → 判失败
- **重试**：同 stage 最多重试 2 次（提示词要求“只修 JSON，不改剧情”）
- **降级**：仍失败 → 使用本地模板：
  - 1 份固定契约（4 个漏洞、1 个致命试探可开关）
  - 1 个固定事件（2 选 1）

---

## 7. API Key 接入（不写入仓库）

不要把真实 Key 写进代码或提交到 git。推荐两种方式：

- **运行时输入**：启动时弹窗输入 key，存 `localStorage`（仅本机）
- **本地环境变量**：使用 `.env.local`（不提交），例如：

```bash
# .env.local（仅本机）
GEMINI_API_KEY=__PUT_YOUR_KEY_HERE__
```

---

## 8. 开发任务拆分（给开发 Agent 的最小清单）

- **前端页面**
  - 主菜单页（开始/成就/升级置灰）
  - 局内页（资源条、摘要卡、按钮区、左侧列表、历史区）
  - 全文弹窗（分段分句 + 引用）
  - 谈判弹窗（引用/解释/反提案/对话记录）
  - 结算页（胜利/失败）

- **状态与逻辑**
  - `gameState`：资源、契约、漏洞、对话记录、事件
  - `applyDeltas()`：资源变更 + clamp
  - `validateLLMJson(stage, obj)`：校验器
  - `callLLM(stage, payload)`：调用封装 + 重试 + 降级

- **LLM 提示词**
  - 3 套系统提示：`offer_generate` / `negotiate` / `event_generate`
  - 必须强制输出 JSON（建议使用“只输出 JSON，不要 Markdown”）

---

## 9. 可直接复制的提示词（原型版最小集）

> 目标：让开发 Agent 不需要再“自己发明提示词”，直接粘贴即可跑通 1 回合闭环。  
> 强制：模型只能输出 **1 个 JSON**，禁止 Markdown/解释/前后缀文字。

### 9.0 `CONTEXT_JSON` 原型最小字段清单（必传）

> 原型只跑 1 回合，为了最快落地，这里只列“必须传”的最小字段。

- `game`: `{ "round": 1 }`
- `player`: `{ "gold": number, "happiness": number, "soul": number }`
- `devil`: `{ "tier": "small", "name": string }`
- `rules`:
  - `min_accept_soul_cost`: 10
  - `loophole_first_offer_count_range`: `[4,6]`
  - `deadly_probe_spawn_chance`: 0.3
- `current_offer_bundle`（仅 negotiate 时必传）：
  - `offer`, `text_index`, `loopholes`, `deadly_probe`
- `conversation_log`（仅 negotiate 时必传）：`Array<{role,content}>`
- `event`（仅 event_generate 时必传）：`{ "node": "between_rounds" }`

### 9.1 通用系统提示词（所有 stage 共用）

```
你是一个贪婪、狡猾但守规则的“魔鬼谈判官”。你的目标是在不出戏的前提下，用最小付出换取玩家尽可能多的灵魂。

你必须遵守：
1) 只输出 1 个 JSON 对象，禁止输出 Markdown、解释、注释、前后缀文本。
2) JSON 必须可解析、字段齐全、类型正确；所有数值变化必须是有限数。
3) 陷阱是文字漏洞，并必须映射到 loopholes[].trigger_condition / penalty_on_accept。
4) 本原型为首次出价：生成 4–6 个漏洞；不得生成不可执行条款。
5) 两层判定：layer1=指到漏洞句；layer2=说清错误原因。layer2 为真必须让步。
```

### 9.2 `offer_generate`（生成契约）

```
stage=offer_generate

CONTEXT_JSON：
{{CONTEXT_JSON}}

输出要求：
- 只输出 JSON，必须符合本原型第 5.1 的结构。
- 生成 4–6 个漏洞（loopholes），每个漏洞必须绑定 quote_ref(p,s)，并提供 detect/issue 关键词。
- 本原型魔鬼 tier=small，deadly_probe 概率 0.3：若 present=true，则必须存在可检测条件会 set_soul_zero；summary 必须包含 warning_text（不剧透具体句子）。
```

### 9.3 `negotiate`（谈判改写）

```
stage=negotiate

CONTEXT_JSON：
{{CONTEXT_JSON}}

PLAYER_QUOTE_REF：
{{PLAYER_QUOTE_REF}}

PLAYER_EXPLAIN：
{{PLAYER_EXPLAIN}}

PLAYER_COUNTER：
{{PLAYER_COUNTER}}

输出要求：
- 只输出 JSON，必须符合本原型第 5.2 结构。
- 输出 matched_loophole_id、layer1/layer2、confidence(0–1)。
- layer2=true 必须 concede 并在 updated_offer 中体现让步。
```

### 9.4 `event_generate`（生成事件）

```
stage=event_generate

CONTEXT_JSON：
{{CONTEXT_JSON}}

输出要求：
- 只输出 JSON，必须符合本原型第 5.3 结构。
- 事件必须戏剧性强但可执行；choices 只能 2 个。
```

### 9.5 `repair_json`（校验失败修复）

```
stage=repair_json

坏 JSON：
{{BAD_JSON}}

校验错误：
{{VALIDATION_ERRORS}}

请只做最小修复，保持原意。只输出修复后的 1 个 JSON。
```

